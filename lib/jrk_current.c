#include "jrk_internal.h"

// See jrk_get_vilim().
static uint16_t jrk_umc04a_30v_vilim_table[32] =
{
  0,
  809,
  1528,
  2178,
  2776,
  3335,
  3865,
  4374,
  4868,
  5352,
  5833,
  6314,
  6799,
  7292,
  7797,
  8319,
  8861,
  9428,
  10025,
  10658,
  11331,
  12054,
  12833,
  13679,
  14604,
  15623,
  16752,
  18014,
  19437,
  21058,
  22923,
  25097,
};

// See jrk_get_vilim().
static uint16_t jrk_umc04a_40v_vilim_table[32] =
{
  0,
  1353,
  2592,
  3742,
  4821,
  5845,
  6826,
  7776,
  8703,
  9615,
  10519,
  11423,
  12333,
  13254,
  14192,
  15154,
  16146,
  17175,
  18247,
  19371,
  20555,
  21809,
  23143,
  24572,
  26109,
  27772,
  29583,
  31566,
  33752,
  36179,
  38894,
  41958,
};

// Given a jrk product code and 5-bit DAC level, this returns the expected
// voltage we will see on the pin of the motor driver that sets the current
// limit.  The units are set such that 0x10000 is the DAC reference, and 0 is
// GND.  Autogenerated from ruby/current_table.rb.
static uint16_t jrk_get_vilim(uint32_t product, uint8_t dac_level)
{
  uint16_t * table;
  if (product == JRK_PRODUCT_UMC04A_40V)
  {
    table = jrk_umc04a_40v_vilim_table;
  }
  else
  {
    table = jrk_umc04a_30v_vilim_table;
  }
  return table[dac_level & 0x1F];
}

// Gets the rsense resistor value for the jrk, in units of milliohms.
static uint8_t jrk_get_rsense_mohm(uint32_t product)
{
  if (product == JRK_PRODUCT_UMC04A_40V)
  {
    return 2;
  }
  else
  {
    return 1;
  }
}


// Calculates the measured current in milliamps for a umc04a board.
//
// current_reading: Raw current reading from the device,
//   from jrk_variables_get_curent_high_res().
// current_limit_code: The hardware current limiting configuration, from
//   from jrk_variables_get_max_current().
// rsense: Sense resistor resistance, in units of mohms.
// current_offset_calibration: from jrk_settings_get_current_offset_calibration()
// current_scale_calibration: from jrk_settings_get_current_scale_calibration()
static int32_t jrk_calculate_measured_current_ma_umc04a(
  uint16_t current_reading,
  uint16_t current_limit_code,
  int16_t duty_cycle,
  uint8_t rsense,
  int16_t current_offset_calibration,
  int16_t current_scale_calibration
  )
{
  if (duty_cycle == 0)
  {
    return 0;
  }

  // Fix the calibration constants so our calculations don't overflow.
  if (current_offset_calibration < -800)
  {
    current_offset_calibration = -800;
  }
  else if (current_offset_calibration > 800)
  {
    current_offset_calibration = 800;
  }

  if (current_scale_calibration < -1875)
  {
    current_scale_calibration = -1875;
  }
  else if (current_scale_calibration > 1875)
  {
    current_scale_calibration = 1875;
  }

  uint8_t dac_ref = current_limit_code >> 5 & 3;

  // Convert the reading on the current sense line to units of mV/16.
  uint16_t current = current_reading >> ((2 - dac_ref) & 3);

  // Subtract the 50mV offset voltage, without making the reading negative.
  uint16_t offset = 800 + current_offset_calibration;
  if (offset > current)
  {
    current = 0;
  }
  else
  {
    current -= offset;
  }

  // The product will be at most 0xFFFF*(2*1875) = 0x0EA5F15A.
  return current * (1875 + current_scale_calibration) / (duty_cycle * rsense);
}

uint32_t jrk_current_limit_code_to_ma(const jrk_settings * settings, uint16_t code)
{
  if (settings == NULL) { return 0; }

  uint32_t product = jrk_settings_get_product(settings);

  if (product == JRK_PRODUCT_UMC04A_30V || product == JRK_PRODUCT_UMC04A_40V)
  {
    // umc04a jrks ignore the top 8 bits and treat codes as zero if the top 3
    // bits are invalid.
    code &= 0xFF;
    if (code > 95) { code = 0; }

    return jrk_calculate_measured_current_ma_umc04a(
      jrk_get_vilim(product, code & 0x1F),
      code,
      600,
      jrk_get_rsense_mohm(product),
      jrk_settings_get_current_offset_calibration(settings),
      jrk_settings_get_current_scale_calibration(settings)
    );
  }

  return 0;
}

int32_t jrk_calculate_measured_current_ma(
  const jrk_settings * settings, const jrk_variables * vars)
{
  if (settings == NULL || vars == NULL) { return 0; }

  uint32_t product = jrk_settings_get_product(settings);

  if (product == JRK_PRODUCT_UMC04A_30V || product == JRK_PRODUCT_UMC04A_40V)
  {
    return jrk_calculate_measured_current_ma_umc04a(
      jrk_variables_get_current_high_res(vars),
      jrk_variables_get_current_limit_code(vars),
      jrk_variables_get_last_duty_cycle(vars),
      jrk_get_rsense_mohm(product),
      jrk_settings_get_current_offset_calibration(settings),
      jrk_settings_get_current_scale_calibration(settings)
    );
  }

  return 0;
}

int32_t jrk_calculate_raw_current_mv64(
  const jrk_settings * settings, const jrk_variables * vars)
{
  if (settings == NULL || vars == NULL) { return 0; }

  uint32_t product = jrk_settings_get_product(settings);

  if (product == JRK_PRODUCT_UMC04A_30V || product == JRK_PRODUCT_UMC04A_40V)
  {
    uint16_t current = jrk_variables_get_current_high_res(vars);
    uint8_t dac_ref = jrk_variables_get_current_limit_code(vars) >> 5 & 3;
    return current << dac_ref;
  }

  return 0;
}
